# Module 4: State Management and Architecture

## Cel modułu
Implementacja zaawansowanego zarządzania stanem i architectural patterns w aplikacji React z wykorzystaniem GitHub Copilot.

## User Stories i Ćwiczenia

### User Story 1: Global state z Context API
**Jako deweloper, chcę mieć centralny store dla stanu aplikacji.**

#### Exercise (Advanced):
1. Stwórz `MoviesContext` z useReducer
2. Implementuj actions dla wszystkich operacji
3. Dodaj middleware dla logging i persistence

**Prompt dla Copilot:**
```typescript
// Generated by Copilot
// Global state management dla aplikacji filmów
// MoviesContext z useReducer pattern
// Actions: FETCH_MOVIES_START, FETCH_MOVIES_SUCCESS, FETCH_MOVIES_ERROR,
//          ADD_MOVIE, UPDATE_MOVIE, DELETE_MOVIE, SET_FILTER, SET_SORT
// State: movies[], loading, error, filters, sortConfig
// Provider component z persistence do localStorage
// Custom hooks: useMoviesState, useMoviesActions
```

### User Story 2: Advanced reducer pattern
**Jako deweloper, chcę mieć przewidywalny sposób aktualizacji stanu.**

#### Exercise (Advanced):
1. Stwórz complex reducer z GitHub Copilot
2. Implementuj immer dla immutable updates
3. Dodaj middleware pattern

**Prompt dla Copilot:**
```typescript
// Generated by Copilot
// Advanced reducer dla zarządzania stanem filmów
// Użyj immer dla immutable updates
// Obsłuż complex state updates: 
//   - optimistic updates z rollback
//   - batch updates dla multiple operations
//   - derived state calculation (filtered and sorted movies)
// Middleware: logger, persistence, error tracking
// Type-safe actions z discriminated unions
```

### User Story 3: Performance optimization
**Jako deweloper, chcę zoptymalizować performance aplikacji.**

#### Exercise (Expert):
1. Implementuj memoization strategię z GitHub Copilot
2. Dodaj virtualization dla długich list
3. Implementuj code splitting

**Prompt dla Copilot:**
```typescript
// Generated by Copilot
// Performance optimization dla aplikacji filmów
// React.memo dla wszystkich komponentów z proper comparison
// useMemo dla expensive calculations (filtered/sorted lists)
// useCallback dla event handlers w parent components
// Virtualization dla długich list filmów (react-window)
// Code splitting z React.lazy dla różnych routes
// Bundle analysis i optimization strategies
```

### User Story 4: Error boundary system
**Jako użytkownik, chcę aby aplikacja gracefully obsługiwała błędy.**

#### Exercise (Advanced):
1. Stwórz comprehensive error boundary system
2. Implementuj error recovery mechanisms
3. Dodaj error tracking i reporting

**Prompt dla Copilot:**
```typescript
// Generated by Copilot
// Comprehensive error boundary system
// ErrorBoundary component z różnymi fallback UI
// Specific boundaries: APIErrorBoundary, RouteErrorBoundary, ChunkErrorBoundary
// Error tracking z console.error i external service integration
// Recovery mechanisms: retry, reload, fallback data
// User-friendly error pages z helpful actions
// Error context dla sharing error state
```

### User Story 5: Offline support i synchronization
**Jako użytkownik, chcę móc korzystać z aplikacji offline.**

#### Exercise (Expert):
1. Implementuj offline support z service workers
2. Dodaj data synchronization przy powrocie online
3. Stwórz conflict resolution strategy

**Prompt dla Copilot:**
```typescript
// Generated by Copilot
// Offline support dla aplikacji filmów
// Service worker dla cache strategies
// IndexedDB dla offline data storage
// Sync queue dla operations wykonanych offline
// Conflict resolution przy sync (last-write-wins lub user choice)
// Online/offline status detection
// Background sync dla pending operations
// Custom hook useOfflineSync()
```

### User Story 6: State machine pattern
**Jako deweloper, chcę mieć predictable state transitions.**

#### Exercise (Expert):
1. Implementuj state machine dla form flow
2. Użyj XState lub custom implementation
3. Dodaj state visualization

**Prompt dla Copilot:**
```typescript
// Generated by Copilot
// State machine dla movie form workflow
// States: idle, editing, validating, saving, success, error
// Transitions z guards i actions
// Side effects: API calls, notifications, navigation
// State persistence between sessions
// Dev tools dla visualization state transitions
// Type-safe state machine z TypeScript
```

## Dodatkowe ćwiczenia

### Exercise 7: Custom hook composition (Advanced)
Stwórz composition pattern dla combining multiple hooks.

### Exercise 8: Undo/Redo functionality (Expert)
Implementuj undo/redo system dla operacji na filmach.

### Exercise 9: Real-time updates (Expert)
Dodaj WebSocket support dla real-time updates z serwera.

## Required Libraries
```bash
# State management
npm install immer

# Performance
npm install react-window react-window-infinite-loader

# State machines (optional)
npm install xstate @xstate/react

# Offline support
npm install dexie workbox-webpack-plugin

# Development tools
npm install @redux-devtools/extension
```

## Architecture Patterns

### 1. Layered Architecture
```
Presentation Layer (Components)
    ↓
Business Logic Layer (Hooks/Services)
    ↓
Data Access Layer (API/Storage)
```

### 2. Feature-based Structure
```
src/
├── features/
│   ├── movies/
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── services/
│   │   └── types/
│   └── shared/
├── app/
└── utils/
```

### 3. Dependency Injection Pattern
```typescript
// Generated by Copilot
// Dependency injection dla testability
// Container dla services i dependencies
// Provider pattern dla injecting dependencies
// Mock factories dla testing
```

## State Management Best Practices

1. **Single Source of Truth** - jeden store dla każdego piece of state
2. **Immutable Updates** - zawsze twórz nowe objects/arrays
3. **Derived State** - calculate derived values on-the-fly
4. **Minimal State** - trzymaj tylko essential data w state
5. **Normalize Data** - avoid deep nesting w state

## Performance Monitoring
```typescript
// Generated by Copilot
// Performance monitoring setup
// React DevTools Profiler integration
// Custom performance hooks
// Bundle size monitoring
// Runtime performance metrics
```

## Testing Architecture
```typescript
// Generated by Copilot
// Testing strategy dla complex state management
// Unit tests dla reducers i hooks
// Integration tests dla context providers
// Performance tests dla heavy operations
// E2E tests dla complete user flows
```

## Security Considerations
1. **Input Validation** - validate all user inputs
2. **XSS Prevention** - sanitize rendered content
3. **State Exposure** - nie expose sensitive data w state
4. **Error Handling** - nie leak sensitive information w errors

## Debugging Tools
1. **React DevTools** - component tree i state inspection
2. **Redux DevTools** - dla complex state debugging
3. **React Query DevTools** - dla server state debugging
4. **Performance Profiler** - dla performance bottlenecks

## Oczekiwane rezultaty
Po ukończeniu tego modułu powinieneś umieć:
- Implementować complex state management z Context API
- Używać advanced patterns (reducer, middleware, state machines)
- Optymalizować performance aplikacji React
- Implementować error boundaries i recovery mechanisms
- Tworzyć offline-capable applications
- Używać architectural patterns dla maintainable code
