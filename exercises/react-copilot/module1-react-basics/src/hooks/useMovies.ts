// Generated by Copilot
// Custom hook React do zarządzania stanem listy filmów
// Powinien zwracać: movies, loading, error, addMovie, updateMovie, deleteMovie
// Powinien używać useState do lokalnego stanu
// Powinien zawierać mock data dla development
import { useState, useEffect, useCallback } from 'react';
import { Movie, CreateMovieData, UpdateMovieData } from '@/types/Movie';

// Type definition for the hook return value
export interface UseMoviesReturn {
  movies: Movie[];
  loading: boolean;
  error: string | null;
  addMovie: (movieData: CreateMovieData) => Promise<void>;
  updateMovie: (id: string, movieData: UpdateMovieData) => Promise<void>;
  deleteMovie: (id: string) => Promise<void>;
  refreshMovies: () => Promise<void>;
  getMovieById: (id: string) => Movie | undefined;
}

// Mock data dla development
const mockMoviesData: Movie[] = [
  {
    id: '1',
    title: 'Oppenheimer',
    director: 'Christopher Nolan',
    ticketPrice: 25.99,
    releaseDate: '2023-07-21'
  },
  {
    id: '2',
    title: 'Barbie',
    director: 'Greta Gerwig',
    ticketPrice: 22.50,
    releaseDate: '2023-07-21'
  },
  {
    id: '3',
    title: 'Dune: Part Two',
    director: 'Denis Villeneuve',
    ticketPrice: 28.00,
    releaseDate: '2024-03-01'
  },
  {
    id: '4',
    title: 'Spider-Man: Across the Spider-Verse',
    director: 'Joaquim Dos Santos',
    ticketPrice: 24.99,
    releaseDate: '2023-06-02'
  },
  {
    id: '5',
    title: 'John Wick: Chapter 4',
    director: 'Chad Stahelski',
    ticketPrice: 26.50,
    releaseDate: '2023-03-24'
  },
  {
    id: '6',
    title: 'Avatar: The Way of Water',
    director: 'James Cameron',
    ticketPrice: 32.99,
    releaseDate: '2024-09-15'
  },
  {
    id: '7',
    title: 'Fast X',
    director: 'Louis Leterrier',
    ticketPrice: 23.75,
    releaseDate: '2023-05-19'
  },
  {
    id: '8',
    title: 'Indiana Jones and the Dial of Destiny',
    director: 'James Mangold',
    ticketPrice: 27.50,
    releaseDate: '2023-06-30'
  }
];

// Simulate network delay for realistic behavior
const simulateNetworkDelay = (ms: number = 500): Promise<void> => {
  return new Promise(resolve => setTimeout(resolve, ms));
};

// Generate unique ID for new movies
const generateMovieId = (): string => {
  return `movie_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
};

// Custom hook for managing movies state
export const useMovies = (): UseMoviesReturn => {
  // Stan lokalny dla filmów
  const [movies, setMovies] = useState<Movie[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  // Initialize movies with mock data
  const initializeMovies = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      // Simulate API call delay
      await simulateNetworkDelay();
      
      // Load mock data
      setMovies(mockMoviesData);
    } catch (err) {
      setError('Błąd podczas ładowania filmów');
      console.error('Error initializing movies:', err);
    } finally {
      setLoading(false);
    }
  }, []);

  // Load movies on component mount
  useEffect(() => {
    initializeMovies();
  }, [initializeMovies]);

  // Add new movie
  const addMovie = useCallback(async (movieData: CreateMovieData): Promise<void> => {
    try {
      setLoading(true);
      setError(null);

      // Validate movie data
      if (!movieData.title.trim()) {
        throw new Error('Tytuł filmu jest wymagany');
      }
      if (!movieData.director.trim()) {
        throw new Error('Reżyser jest wymagany');
      }
      if (movieData.ticketPrice <= 0) {
        throw new Error('Cena biletu musi być większa od 0');
      }
      if (!movieData.releaseDate) {
        throw new Error('Data wydania jest wymagana');
      }

      // Simulate API call
      await simulateNetworkDelay(300);

      // Create new movie with generated ID
      const newMovie: Movie = {
        id: generateMovieId(),
        ...movieData
      };

      // Add to state
      setMovies(prevMovies => [...prevMovies, newMovie]);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Błąd podczas dodawania filmu';
      setError(errorMessage);
      throw err; // Re-throw to allow component to handle it
    } finally {
      setLoading(false);
    }
  }, []);

  // Update existing movie
  const updateMovie = useCallback(async (id: string, movieData: UpdateMovieData): Promise<void> => {
    try {
      setLoading(true);
      setError(null);

      // Check if movie exists
      const existingMovie = movies.find(movie => movie.id === id);
      if (!existingMovie) {
        throw new Error('Film nie został znaleziony');
      }

      // Validate updated data
      if (movieData.title !== undefined && !movieData.title.trim()) {
        throw new Error('Tytuł filmu nie może być pusty');
      }
      if (movieData.director !== undefined && !movieData.director.trim()) {
        throw new Error('Reżyser nie może być pusty');
      }
      if (movieData.ticketPrice !== undefined && movieData.ticketPrice <= 0) {
        throw new Error('Cena biletu musi być większa od 0');
      }

      // Simulate API call
      await simulateNetworkDelay(300);

      // Update movie in state
      setMovies(prevMovies =>
        prevMovies.map(movie =>
          movie.id === id
            ? { ...movie, ...movieData }
            : movie
        )
      );
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Błąd podczas aktualizacji filmu';
      setError(errorMessage);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [movies]);

  // Delete movie
  const deleteMovie = useCallback(async (id: string): Promise<void> => {
    try {
      setLoading(true);
      setError(null);

      // Check if movie exists
      const existingMovie = movies.find(movie => movie.id === id);
      if (!existingMovie) {
        throw new Error('Film nie został znaleziony');
      }

      // Simulate API call
      await simulateNetworkDelay(300);

      // Remove movie from state
      setMovies(prevMovies => prevMovies.filter(movie => movie.id !== id));
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Błąd podczas usuwania filmu';
      setError(errorMessage);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [movies]);

  // Refresh movies (reload mock data)
  const refreshMovies = useCallback(async (): Promise<void> => {
    await initializeMovies();
  }, [initializeMovies]);

  // Get movie by ID
  const getMovieById = useCallback((id: string): Movie | undefined => {
    return movies.find(movie => movie.id === id);
  }, [movies]);

  // Return hook interface
  return {
    movies,
    loading,
    error,
    addMovie,
    updateMovie,
    deleteMovie,
    refreshMovies,
    getMovieById
  };
};